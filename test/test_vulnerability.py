import os
import sys
import time

# Add project root to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from verus.clustering import GeOPTICS, KMeansHaversine
from verus.data.extraction import DataExtractor
from verus.data.timewindow import TimeWindowGenerator
from verus.grid.hexagon import HexagonGridGenerator
from verus.verus import VulnerabilityAssessor

if __name__ == "__main__":
    # Set up proper output directory using absolute path
    base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "data"))
    print(f"Using base directory: {base_dir}")

    # Set place parameters
    place_name = "Porto"
    region = f"{place_name}, Portugal"

    # Create results directory
    results_dir = os.path.join(base_dir, "results", place_name)
    os.makedirs(results_dir, exist_ok=True)

    # Define other directories
    poti_dir = os.path.join(base_dir, "poti")
    time_windows_dir = os.path.join(base_dir, "time_windows")
    geojson_dir = os.path.join(base_dir, "geojson")
    maps_dir = os.path.join(base_dir, "maps")
    clusters_dir = os.path.join(base_dir, "clusters")

    # Ensure all directories exist
    for directory in [poti_dir, time_windows_dir, geojson_dir, maps_dir, clusters_dir]:
        os.makedirs(directory, exist_ok=True)

    print("Step 1: Extract POI data")
    # First check if we have a dataset already
    dataset_path = os.path.join(poti_dir, f"{place_name}_dataset_buffered.csv")

    if not os.path.exists(dataset_path):
        extractor = DataExtractor(
            region=region,
            buffer_distance=500,
            output_dir=base_dir,
            verbose=True,
        )
        poi_df = extractor.run(save_dataset=True)
    else:
        print(f"Using existing dataset: {dataset_path}")
        import pandas as pd

        poi_df = pd.read_csv(dataset_path)

    print("Step 2: Generate time windows")
    # Generate time windows if they don't exist
    time_window_files = [f for f in os.listdir(time_windows_dir) if f.endswith(".csv")]

    if not time_window_files:
        tw_generator = TimeWindowGenerator(
            output_dir=base_dir,
            reference_date="2023-11-06",
            verbose=True,
        )
        tw_generator.generate_from_schedule(clear_existing=True)
    else:
        print(f"Using existing time windows: {len(time_window_files)} files found")

    print("Step 3: Generate hexagonal grid")
    # Define the filename for the hexagonal grid
    hex_grid_file = os.path.join(
        geojson_dir, place_name, f"{place_name}_hex_grid_clipped.geojson"
    )

    if not os.path.exists(hex_grid_file):
        hex_generator = HexagonGridGenerator(
            region=region,
            edge_length=250,
            output_dir=base_dir,
            verbose=True,
        )
        hex_grid = hex_generator.run(save_output=True)
    else:
        print(f"Using existing hex grid: {hex_grid_file}")

    print("Step 4: Run OPTICS + KMeans clustering")
    # Define file paths for clustering outputs
    clusters_file = os.path.join(
        clusters_dir, f"{place_name}_Clusters_KM-OPTICS_ET4.csv"
    )
    centroids_file = os.path.join(
        clusters_dir, f"{place_name}_Centroids_KM-OPTICS_ET4.csv"
    )

    if not (os.path.exists(clusters_file) and os.path.exists(centroids_file)):
        # Run OPTICS
        optics = GeOPTICS(
            min_samples=5,
            xi=0.05,
            min_cluster_size=5,
            output_dir=base_dir,
            verbose=True,
        )

        optics_results = optics.run(
            data_source=dataset_path,
            place_name=place_name,
            time_windows_path=time_windows_dir,
            evaluation_time="ET4",
            save_output=False,
        )

        # Run KMeans with OPTICS results
        n_clusters = 8
        if optics_results["centroids"] is not None:
            n_clusters = len(optics_results["centroids"])

        kmeans = KMeansHaversine(
            n_clusters=n_clusters,
            output_dir=base_dir,
            verbose=True,
        )

        kmeans.run(
            data_source=optics_results["input_data"],
            place_name=place_name,
            evaluation_time="ET4",
            centers_input=optics_results["centroids"],
            save_output=True,
            algorithm_suffix="KM-OPTICS",
        )
    else:
        print(
            f"Using existing clustering results:\n- {clusters_file}\n- {centroids_file}"
        )

    print("Step 5: Run the vulnerability assessment")
    # Define simple time scenarios
    et_scenarios = {
        "ET4": {
            "name": "Evening Peak",
            "description": "Weekday evening peak hour",
            "datetime": int(time.time()),  # Use current time for simplicity
        }
    }

    # Initialize the VulnerabilityAssessor with minimal config
    assessor = VulnerabilityAssessor(
        place_name=place_name,
        method="KM-OPTICS",
        evaluation_time="ET4",
        distance_method="gaussian",
        sigma=1000,
        adaptive_radius=1500,
    )

    # Set the time scenarios directly
    assessor.config = type("SimpleConfig", (), {})()
    assessor.config.et_scenarios = et_scenarios

    # Load required data
    assessor.load(
        poti_file=clusters_file,
        centroids_file=centroids_file,
        zones_file=hex_grid_file,
        time_windows_dir=time_windows_dir,
    )

    # Run the assessment
    print("\nRunning vulnerability assessment with gaussian method...")
    results = assessor.run(
        save_output=True,
        output_dir=results_dir,
        run_clustering=False,  # We already ran clustering separately
    )

    print("\nVulnerability Assessment Completed Successfully!")
    print(f"- {len(results['vulnerability_zones'])} zones processed")
    print(f"- Results saved to: {results_dir}")

    # Optional: Test another distance method to verify flexibility
    print("\nTesting adaptive distance method...")
    assessor.distance_method = "adaptive"
    adaptive_results = assessor.run(
        save_output=True,
        output_dir=results_dir,
        run_clustering=False,
    )

    print("\nTest completed successfully!")
